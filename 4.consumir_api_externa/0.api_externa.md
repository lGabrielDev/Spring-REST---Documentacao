<h1 align="center">
    <span>Consumir API externa</span>
    <img src="https://cdn4.iconfinder.com/data/icons/web-design-and-development-8-1/64/380-512.png" alt="image" width="100px" align="center">
</h1>


O fluxo de consultar dados externos √© bem parecido com o fluxo de consultar dados locais.

<img src="../imgs/fluxo_dados_locais.png" alt="image example" width="800px">


<br>

Entendendo o fluxo de dados local:

- Cliente faz um request/solicitacao HTTP para um endpoint espec√≠fico da nossa aplica√ß√£o.

- A Controller verifica o endpoint solicitado, executa o method correspondente, e chama a service.

- A Service trata a l√≥gica de neg√≥cio, valida se o request t√° tudo certinho e depois chama a repository.

- O Repository faz as consultas no banco de dados local para buscar os dados solicitados no request.

- O fluxo retorna.


<br>
<br>

<img src="../imgs/fluxo_dados_externos.png" alt="image example" width="800px"> 

<br>

Aqui, o fluxo para consultar dados externos √© bem parecido. A diferen√ßa √© que ao inv√©s de consultar no nosso banco local, vamos consultar em uma aplicacao externa.

- Cliente faz um request/solicitacao HTTP para um endpoint espec√≠fico da nossa aplica√ß√£o.

- A Controller verifica o endpoint solicitado, executa o method correspondente, e chama a service.

- A Service trata a l√≥gica de neg√≥cio, valida se o request t√° tudo certinho e **faz uma solicitacao para a api externa**.

- A API externa faz todo o procedimento de uma aplicacao local (Controller, Service, Repository e Banco de dados) e devolve para a nossa Service o dado solicitado no request.

- O fluxo retorna.



<hr>
<br>


## Passo a passo <img src="https://cdn4.iconfinder.com/data/icons/agile-methodology-flaticon/64/requirement-steps-planning-documents-clipboard-512.png" alt="icon image" width="70px" align="center">

Para conectar nossa aplicacao com uma aplicacao externa, vamos seguir os seguintes passos:


1. Adicionar a dependencie do feign client (cliente falso). **OpenFeign**

<br>

2. Ir na Main Class da aplica√ß√£o e liberar a permissao para acessar APIs externas, utilizando o `@EnableFeignClients`

<br>

3. Criar uma class DTO para receber os attributes do objeto enviado. Como √© uma DTO, n√≥s podemos escolher quais attributes queremos receber. Por√©m, **O NOME DOS ATTRIBUTES DEVE SER IGUAL AO NOME DOS ATTRIBUTES DO OBJETO JSON ENVIADO** .

<br>

4. Criar uma interface para representar a Controller Class da API externa. Funciona igualzinho uma Controller, mas apenas com abstracts methods. Vamos usar um objeto dessa interface para fazer os requests para a api externa.

<br>

5. Criamos uma Service e uma Controller padraozinha.


<hr>
<br>

## Maos na massa:

Vamos utilizar a API externa da [viaCep](https://viacep.com.br/) para praticarmos. O objetivo vai ser:

O cliente vai fazer, na nossa API, um request para trazer as informacoes de um determinado CEP.

<br>

### Criando o projeto Spring

‚úèÔ∏è Crie um projeto Spring com as seguintes dependencies:

- Lombok --> Getters, Setters and Constructors j√° criados
- DevTools --> A cada alteracao, reiniciar nossa aplicacao automaticamente
- Spring Web --> Nossa aplicacao RestFul
-  **OpenFeign** --> Essa √© a dependencie que nos permite fazer requests para APIs externas


<br>

Importante lembrar que a dependencie do **OpenFeign** recebe todas essas informacoes:

```xml
<properties>
		<java.version>17</java.version>
		<spring-cloud.version>2023.0.0</spring-cloud.version> <!-- informamos a versao -->
</properties>

<!-- outras dependencies ^^^^ -->
<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-openfeign</artifactId>
			<version>4.0.4</version>
</dependency>
<!-- outras dependencies -->


<dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-dependencies</artifactId>
			<version>{spring-cloud-version}</version>
			<type>pom</type>
			<scope>import</scope>
		</dependency>
	</dependencies>
</dependencyManagement> 
```


<hr>
<br>


### Criando nossa DTO Class para receber o objeto JSON da api externa

Vamos na [ViaCep](https://viacep.com.br/) e verificamos quais s√£o os attributes que o objeto JSON possui:

```json
{
    "cep": "01001-000",
    "logradouro": "Pra√ßa da S√©",
    "complemento": "lado √≠mpar",
    "bairro": "S√©",
    "localidade": "S√£o Paulo",
    "uf": "SP",
    "ibge": "3550308",
    "gia": "1004",
    "ddd": "11",
    "siafi": "7107"
}        
```


Como estamos trabalhando com DTO, n√≥s podemos escolher quais os attributes que nos interessa. No caso, vamos querer apenas os attributes:

 - cep
 - logradouro
 - complemento
 - bairro
 - localidade
 - uf


<br>

‚ö†Ô∏è Lembrando que os nomes dos attributes da nossa DTO Class **PRECISAM** ter o mesmo nome dos attributes do objeto JSON da API externa.

<br>

‚úèÔ∏è Crie  uma DTO Class representando o objeto JSON da API externa

```java
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter

public class Address {

    //attributes
    private String cep;
    private String logradouro;
    private String complemento;
    private String bairro;
    private String localidade;
    private String uf;

    //constructors --> Criados pelo lombok

    //getters and setters --> Criados pelo lombok

    //toString()
    @Override
    public String toString(){
        return
            String.format(
                "Cep: %s\n" +
                "Logradouro: %s\n" +
                "Complemento: %s\n" +
                "Bairro: %s\n" +
                "Cidade: %s\n" +
                "UF: %s\n", this.cep, this.logradouro, this.complemento, this.bairro, this.localidade, this.uf
            );
    }
}
```

Denovo, n√≥s precisamos dar o mesmo nome aos attributes. Se n√£o fizermos assim e criarmos attributes com nomes diferentes, eles receberiam null sacou?? Isso, porque o objeto JSON enviado possui aqueles exatos attributes.

<hr>
<br>


### Criando uma interface para representar a Controller class da API externa

√â atrav√©s dessa interface que vamos conseguir fazer os requests para a API externa. Ao inv√©s de consultar os dados no banco de dados, n√≥s vamos fazer requests para pegar esses dados.

Essa interface vai fingir ser um "cliente". Por isso, `@FeignClient`.

<br>

```java
package br.com.lGabrielDev.api_externa.models.external_api;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import br.com.lGabrielDev.api_externa.models.address.Address;

@FeignClient(
    name = "viacepBolado",
    url = "viacep.com.br/ws/" //representa o "@RequestMapping da controller dos caras"
)
public interface ExternalApiController {
    
    //rotas
    @GetMapping("{cep}/json") //estamos fazendo um request para essa rota
    public Address findAddressByCep(@PathVariable(value = "cep") String cep);


    //entendendo o c√≥digo vai ficar assim:
    /*
     * - Ao instanciar um objeto dessa Interface, estamos fazendo um request/solicitacao para a api externa
     * - Informamos o method/rota que queremos fazer o request. Sacou???
     */
}
```

üí° Perceba que √© aqui que vamos dizer qual vai ser a Class do objeto JSON retornado. Nesse caso, o objeto JSON que a api externa **viacep** vai retornar ser√° um objeto do tipo "**Address**". Se ligou?? No retorno do method √© que informamos.


<hr>
<br>


### Criando uma Service e uma Controller padraozinhas

#### Service

√â aqui que instanciamos um objeto da Interface. √â com esse objeto que vamos fazer os requests para a aplicacao externa.

<br>

```java
@Service
public class AddressService {
    
    //injected attributes
    @Autowired
    private ExternalApiController eac; //esse eh o attribute que vamos usar para fazer os requests para a external api


    // Find an address by CEP
    public Address findyAddressByCep(String cep){
        
        Address addressConsultado = new Address(); //criamos um objeto "Address" para retornar        
        addressConsultado = this.eac.findAddressByCep(cep); //Esse objeto "Address" vai receber o JSON da API externa
        
        return addressConsultado;
    }
}
```

<br>
<br>

#### Controller

```java
@RestController //essa e uma class controladora de rotas
@RequestMapping(path = "/api") //definimos o caminho padrao da nossa url
public class AddressController {
    
    //injected attributes
    @Autowired
    private AddressService as;

    //rotas
    @GetMapping("/{cep}")
    public Address getAddressByCep(@PathVariable(value = "cep") String cep){
        return as.findyAddressByCep(cep);
    }
}
```

O fluxo ficou assim:

- O cliente faz uma solicitacao/request na nossa aplicacao.
- A controller recebe e manda para a service.
- A service recebe e faz uma solicitacao para a api externa, atraves da interface criada. Por isso, a interface que criamos √© chamada de `@FeignClient`. Ela se passa por um "cliente".
- O fluxo retorna.


<br>

üòé Dale!! Nos passamos por um "cliente falso" e fizemos um request para uma API externa. Dale !!!!!


<br>

Agora, vamos aprender a tratar as possiveis `FeignExceptions`.



 <h1 align="center">
    Customizando nosso ResponseEntity<>
    <img alt="image icon" src="https://cdn2.iconfinder.com/data/icons/alert-message/64/siren-light-exclamation-icon-256.png" width="90px" align="center">
 </h1>

Sempre que o usu√°rio/cliente faz uma requisi√ß√£o/request que d√° erro, precisamos lancar uma Exception para o cliente.

Quando estamos trabalhando com API, o tipo de exception que vamos usar ser√° a `RuntimException`.

Quando essa RuntimeException acontece, √© informado um `ResponseEntity`(entidade de resposta de erro) ao cliente:



<img alt="image example" src="../imgs/response_entity.png" width="900px" align="center">

<br>

N√≥s podemos customizar esse `ResponseEntity<>`, ficando mais amig√°vel para quem estiver recebendo essa **RuntimeException**.


Ainda trabalhando com o projeto *Student*, criado [aqui](../0.criando_RestApi/2.studentClass.md), vamos seguir os seguintes passos para conseguir customizar essas mensagens de erro:


1. Vamos criar nossas proprias Classes filhas/extends de `RuntimeException`.
2. Criar uma class auxiliar com todos os attributes da mensagem de erro:
    - "**timestamp**":
    - "**status**":
    - "**error**": 
    - "**trace**"

3. Criar uma Class para customizar as nossas **RuntimeExceptions**.

<hr>
<br>

## Criando nossas proprias Exceptions, filhas de `RuntimeException`

Vamos pegar o seguinte caso de erro do nosso projeto:

O usu√°rio faz um request para retonar um Student pelo #ID.

```java
//SERVICE

//READ by #ID
public Student getStudentById(Long id){
    //verificamos se conseguimos encontrar um Student, ou null
    Optional<Student> sOptional = this.sr.findById(id);

    if(sOptional.isEmpty()){
        throw new RuntimeException("Student nao encontrado"); // usamos a RuntimeException gen√©rica
    }
    return sOptional.get();
}
```

Perceba que usamos a pr√≥pria class de exception `RuntimeException`. Por√©m, est√° muito gen√©rico. Precisamos criar nossa pr√≥pria exception "Student nao encontrado".


‚úèÔ∏èCrie um package "Exceptions", e armazene suas exceptions l√°.

- üìï Exceptions:
    - **StudentNotFoundException.java**
    - DateOfBirthCannotBeNull.java
    - NameCannotBeNull.java
    - EmailCannotBeNull.java
    - EmailAlreadyExists.java



Para isso, basta criarmos uma Exception padraozinho. Essa exception ser√° filha de `RuntimeException`:

```java
public class StudentNotFoundException extends RuntimeException{

    //constructors
    public StudentNotFoundException(String errorMessage){
        super(errorMessage);
    }
}
```



Beleza! Temos nossas pr√≥prias `RuntimeException`.

<br>

Agora sim, podemos lancar nossas proprias RuntimeExceptions:

```java
public Student getStudentById(Long id){
    //verificamos se conseguimos encontrar um Student, ou null
    Optional<Student> sOptional = this.sr.findById(id);

    if(sOptional.isEmpty()){
        throw new StudentNotFoundException("Student nao encontrado"); // usamos a RuntimeException gen√©rica
    }
    return sOptional.get();
}
```

Por√©m, ainda precisamos customizar essas exceptions.

<hr>
<br>

## Criando uma Class auxiliar com todos os attributes da mensagem de erro
Sempre que vamos enviar uma resposta HTTP, `ResponseEntity<>`, precisamos informar um objeto que vai dentro <> dessa resposta. Esse objeto √© nada mais nada menos que uma instancia dessa Class auxiliar que vamos criar.

Por isso que sempre que temos uma resposta HTTP, visualizamos um objeto JSON. A Instancia dessa Class ser√° o nosso objeto JSON dessa resposta.


Vamos copiar os mesmos attributes de uma resposta HTTP padrao:

 - "**timestamp**": --> Horario atual
- "**status**": --> N√∫mero do Erro (400,404,etc...)
- "**error**":  --> Mensagem do Erro
- "**trace**" --> caminho onde o erro acontceu


```java
package br.com.lGabrielDev.projetinhoFelas.exceptions;
import java.time.LocalDateTime;

public class ErrosPadronizados {
    
    //attributes --> Os mesmos de quando recebemos um erro na requisicao. Se ligou??
    private LocalDateTime timestamp;
    private Integer status;
    private String error;
    private String trace;


    //constructors
    public ErrosPadronizados(){}

    public ErrosPadronizados(LocalDateTime timestamp, Integer status, String error, String trace){
        this.timestamp = timestamp;
        this.status = status;
        this.error = error;
        this.trace = trace;
    }


    //getters and setters
    public String getTimestamp() {
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String dataFormatada = dtf.format(this.timestamp);
        
        return dataFormatada;
    }

    public void setTimestamp(LocalDateTime timestamp){
        this.timestamp = timestamp;
    }

    public Integer getStatus() {
        return status;
    }

    public void setStatus(Integer status) {
        this.status = status;
    }

    public String getError() {
        return error;
    }

    public void setError(String error) {
        this.error = error;
    }

    public String getTrace() {
        return trace;
    }

    public void setTrace(String trace) {
        this.trace = trace;
    }
}
```

Perceba que criamos uma Class padraozinho como qualquer outra. Easy! üòé

<br>

‚ö†Ô∏è  Quando voc√™ retorna um objeto no body da ResponseEntity, o que √© realmente convertido em JSON s√£o os m√©todos `getters()` e n√£o o m√©todo toString().

Por isso que voc√™ precisar usar o **DateTimeFormater** l√° no `get()`.

<hr>
<br>

## Class para customizar nossa RuntimeExceptions
Para definir uma Class como a Class global de customiza√ß√£o de RuntimeExceptions, precisamos usar 2 annotations:

- `@ControllerAdvice` --> Dizemos que essa Class √© respons√°vel em customizar a resposta HTTP, ResonseEntity<>, das RuntimeExceptions

- `@ExceptionHandler` --> Sempre que "tal" RuntimeException acontecer, o method abaixo ser√° executado.

```java
@ControllerAdvice //essa class vai customizar todas as RuntimeExceptions
public class CustomizandoErros {
    
    //RuntimeExceptions1
    @ExceptionHandler(StudentNotFoundException.class) //essa annotation diz que sempre que essa Exception acontecer, devemos chamar o method abaixo
    public ResponseEntity<ErrosPadronizados> handleStudentNotFoundException(StudentNotFoundException e){ //informamos que esse method vai retornar uma respota HTTP. Dentro dessa resposta <Vamos ter um objeto "ErroPadronizado">. Mostrando seus attributes e seus respectivos valores (Um JSON).
        
        //criamos um objeto "ErrosPadronizados". Esse √© o objeto que est√° dentro da reposta HTTP <>. Ou seja, √© o objeto que vamos retornar dentro da resposta HTTP. 
        ErrosPadronizados ep = new ErrosPadronizados(
            LocalDateTime.now(),
            HttpStatus.NOT_FOUND.value(),//int
            e.getMessage(), //mensagem que setamos quando lancamento a exception
            e.getStackTrace().toString()
        );
        
        return ResponseEntity
            .status(HttpStatus.NOT_FOUND)
            .body(ep);
    }

    //RuntimeExceptions2

    //RuntimeExceptions3
    
    //etc...
}
```
Poder√≠amos retornar um `ResponseEntity<Object>`. Daria certo tamb√©m.

Easy! üòé

<br>

Agora, customize todas as possiveis RuntimeExceptions:

### Exceptions ao procurar por #ID
- student not found

<br>

### Exceptions ao criar um Student
- campo "dateOfBirth" n√£o pode ser nulla
- campo "name" n√£o pode ser null
- campo "email" n√£o pode ser null
    - "email" j√° existe

<br>

### Exceptions ao deletar um #Student   
- #44 Student not found

<br>

### Exceptions ao atualizar um Student
- #44 Student not found
- "email" ja existe



```java
package br.com.lGabrielDev.projetinhoFelas.exceptions;
import java.time.LocalDateTime;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@ControllerAdvice // Essa class ser√° respons√°vel em customizar a resposta de todas as RuntimeExceptions
public class GlobalRunTimeExceptionHandler {
    
    //RuntimeExceptions

    //StudentNotFound
    @ExceptionHandler(StudentNotFoundException.class)
    public ResponseEntity<ErrosPadronizados> StudentNotFoundException(StudentNotFoundException e){
        ErrosPadronizados ep = new ErrosPadronizados();
        ep.setTimestamp(LocalDateTime.now());
        ep.setStatus(HttpStatus.NOT_FOUND.value());
        ep.setError(e.getMessage());
        ep.setTrace(e.getStackTrace().toString());

        return ResponseEntity
            .status(HttpStatus.NOT_FOUND)
            .body(ep);
    }


    //DateOfBirthCannotBeNull
    @ExceptionHandler(DateOfBirthCannotBeNull.class)
    public ResponseEntity<ErrosPadronizados> DateOfBirthCannotBeNull(DateOfBirthCannotBeNull e){
        ErrosPadronizados ep = new ErrosPadronizados(
            LocalDateTime.now(),
            HttpStatus.NOT_ACCEPTABLE.value(),
            e.getMessage(),
            e.getStackTrace().toString()
        );

        return ResponseEntity
            .status(HttpStatus.NOT_ACCEPTABLE)
            .body(ep);
    }


    //NameCannotBeNull
    @ExceptionHandler(NameCannotBeNull.class)
    public ResponseEntity<ErrosPadronizados> NameCannotBeNull(NameCannotBeNull e){
        ErrosPadronizados ep = new ErrosPadronizados(
            LocalDateTime.now(),
            HttpStatus.NOT_ACCEPTABLE.value(),
            e.getMessage(),
            e.getStackTrace().toString()
        );

        return ResponseEntity
            .status(HttpStatus.NOT_ACCEPTABLE)
            .body(ep);
    }


    //EmailCannotBeNull
    @ExceptionHandler(EmailCannotBeNull.class)
    public ResponseEntity<ErrosPadronizados> EmailCannotBeNull(EmailCannotBeNull e){
        ErrosPadronizados ep = new ErrosPadronizados(
            LocalDateTime.now(),
            HttpStatus.BAD_REQUEST.value(),
            e.getMessage(),
            e.getStackTrace().toString()
        );

        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(ep);
    }


    //EmailAlreadyExists
    @ExceptionHandler(EmailAlreadyExists.class)
    public ResponseEntity<ErrosPadronizados> EmailAlreadyExists(EmailAlreadyExists e){
        ErrosPadronizados ep = new ErrosPadronizados(
            LocalDateTime.now(),
            HttpStatus.CONFLICT.value(),
            e.getMessage(),
            e.getStackTrace().toString()
        );

        return ResponseEntity
            .status(HttpStatus.CONFLICT)
            .body(ep);
    }
}
```

Agora sabemos como customizar uma **mensagem Http / ResponseEntity<>** üòé

<br>
<br>

## Alem disso, vamos tratar as exceptions de Erro De input

Se o cliente digitar uma String ao inves de um Integer.

Poss√≠veis erros:

- Cliente tenta localizar/editar/deletar um Student pelo #ID, mas passa uma String.
- Cliente passa uma String no requestParam "rows"

 Nesses casos, √© gerado uma `MethodArgumentTypeMismatchException`.


 <br>

üí° Para saber o nome da RuntimeExceptin que aconteceu, basta fazer um request e visualizar a Exception na resposta da requisicao. Assim, nao precisamos decorar esses erros.

 <br>

‚úèÔ∏è Customize essa Runtime Exception do jeito que aprendemos:

```java
//MethodArgumentTypeMismatchException --> Essa exception acontece quando colocamos uma String ao inves de um dataType Number (Integer, Long, etc..)
//vamos tratar 2 poss√≠veis erros:
//1. Cliente tenta localizar/editar/deletar um Student pelo #ID, mas passa uma String
//2. Cliente passa uma String no requestParam "rows"

@ExceptionHandler(MethodArgumentTypeMismatchException.class)
public ResponseEntity<ErroPadrao> MethodArgumentTypeMismatchException(MethodArgumentTypeMismatchException e){

    String mensagemDeErro = "";
    
    if(e.getName().equals("id")){
        mensagemDeErro = "The Student #ID must be an Integer!";
    }
    else if(e.getName().equals("rows")){
        mensagemDeErro = "The parameter 'rows' must be an Integer";
    }
    
    
    //criamos o objeto que vamos enviar na resposta da requisicao
    ErroPadrao e1 = new ErroPadrao();
    e1.setTimestamp(LocalDateTime.now());
    e1.setStatus(HttpStatus.BAD_REQUEST.value());
    e1.setError(mensagemDeErro);
    

    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e1);
}
```

Perceba que localizamos o parametro que aconteceu o erro, utilizando o `e.getName()`.


üìñ Vale lembrar que, tanto a `@PathVariable` quanto os `@RequestParam` S√ÉO CONSIDERADOS par√¢metros no geral. Eles s√£o apenas formas diferentes de passar par√¢metros. Os dois s√£o par√¢metros.

Por isso, quando usamos o e.`getName()`, conseguimos saber o nome do par√¢metro que aconteceu o erro. Assim, fica mais f√°cil de customizar, conseguindo criar uma mensagem espec√≠fica para cada parametro.


- Se aconteceu o erro no parametro "tal1", exibimos tal mensagem.
- Se aconteceu o erro no parametro "tal2", exibimos tal mensagem.
- etc...
<h1 align="center">
    @Service 
    <img src="https://cdn2.iconfinder.com/data/icons/business-methodologies-flat/60/Bug-Search-corporate-squash-bugs-errors-512.png" alt="routes icon" width="90px" align="center">
</h1>

A Service class processa as requisi√ß√µes feitas na controller class. √â aqui que vamos criar os methods para validar os dados das requisi√ß√µes. √â aqui que tratamos os poss√≠veis erros de requsi√ß√£o.

Para definir uma Class como Service, usaremos a annotation `@Service`.

‚úèÔ∏è Traga aquele c√≥digo da controller para c√°.

- üìô Student
    - Student --> *Entity*
    - StudentController
    - **StudentService**

<br>

## Criando nossa Service class

```java
package br.com.empresaTal.spring_praticando.student;

import java.util.List;
import java.time.LocalDate;
import org.springframework.stereotype.Service;

@Service //essa eh a class de service. Aqui, vamos fazer as l√≥gicos do neg√≥cio
public class StudentService {
    
    // injected attributes
    //injetaremos a repository depois...


    //rota 1
    public String rotaSimples1(){
        return "Rota simples =D";
    }

    //rota 2
    public List<Student> getStudents(){
        return
            List.of(
                new Student(1l, "batman", "batman@gmail.com", LocalDate.of(1997, 4, 11)),
                new Student(2l, "naruto", "naruto@gmail.com", LocalDate.of(2004, 2, 17)),
                new Student(3l, "hinata", "hinata@gmail.com", LocalDate.of(1980, 7, 5))
            );
    }
}
```

<hr>

## Chamando a Service na Controller

Agora, na Controller Class vamos criar um attribute da class Service. Assim, podemos utilizar os methods de l√°. Por√©m, pra utilizar esses methods, precisamos instanciar esse atribute.

<br>

```java
@RestController //Essa class √© uma class controladora que recebe os requests e retorna objetos JSON. √â aqui que criamos nossas rotas.
@RequestMapping("/api/v1") //setamos a URL padrao. Nesse caso http://localhost:8080/api/v1/
public class StudentController {

    //attributes
    private StudentService ss;


    //constructors
    public StudentController(StudentService ss){
        this.ss = ss;
    }

    
    //rota 1
    @GetMapping("/rota1")
    public String rota1(){
        return this.ss.rotaSimples1();
    }

    //rota 2
    @GetMapping("/students")
    public List<Student> rota2(){
        
        return this.ss.getStudents();
    }
}
```

<br>

### Entendendo o fluxo

- O cliente faz uma requisi√ß√£o para a nossa API.

- A classe controladora √© instanciada.

- Como toda classe, sempre que instanciamos uma classe, o primeiro m√©todo a ser executado √© o m√©todo construtor.

- O Spring preenche os par√¢metros desse m√©todo construtor automaticamente. O par√¢metro esperado √© uma inst√¢ncia de "StudentService". O Spring procura, na aplica√ß√£o, por essa classe com a anota√ß√£o adequada (como @Service, @Component, etc.). Se encontrar, ele considera essa classe uma depend√™ncia e a instancia automaticamente.

- Em seguida, a controller verifica qual rota o cliente acessou e executa o m√©todo correspondente.

- Esse m√©todo chama a Service para lidar com o pedido.

- A Service processa o pedido, verifica se h√° erros e devolve a informa√ß√£o para a controller.

- A controller recebe a informa√ß√£o e a retorna para o cliente.

<br>

üìñ Toda class que tiver uma `@Annotation`, √© considerado pelo spring como uma depend√™ncia. Assim, sempre que tiver algum attribute com annotation(dependencia) dentro de um constructor, ele ser√° instanciado automaticamente.

üìñ O spring injeta/instancia qualquer objeto que for de uma Class com alguma `@Annotation`.

<hr>
<br>


## Chamando a Service na Controller, utilizando `@Autowired`

Aqui, vamos trabalhar com **inje√ß√£o de depend√™ncia**.

Ao inv√©s de criarmos um constructor, podemos injetar esse attribute de forma autom√°tica.

```java
@RestController //Essa class √© uma class controladora que recebe os requests e retorna objetos JSON. √â aqui que criamos nossas rotas.
@RequestMapping("/api/v1") //setamos a URL padrao. Nesse caso http://localhost:8080/api/v1/
public class StudentController {

    //injected attributes
    @Autowired
    private StudentService ss;
    
    //rota 1
    @GetMapping("/rota1")
    public String rota1(){
        return this.ss.rotaSimples1();
    }

    //rota 2
    @GetMapping("/students")
    public List<Student> rota2(){
        
        return this.ss.getStudents();
    }
}
```

Perceba que aqui n√£o precisamos de constructor. Quando rodamos a aplica√ß√£o, √© instanciado o attribute `StudentService ss` automaticamente. Isso acontece porque usamos a annotation `@Autowired`.

<br>

### Entendendo o fluxo
- Cliente faz uma requisi√ß√£o pra nossa API.
- Nossa controller class √© instanciada
- Como n√£o tem constructor, todos os attributes que tiverem `@Autowired` ser√£o instanciados automaticamente.
- Em seguida, a controller verifica qual a rota que o cliente acessou e executa o method correspondente a essa rota.
- Esse method chama a Service para lidar com esse pedido.
- A Service faz o tratamento desse pedido, verifica se tem algum erro e devolve a informacao para a Controller.
- A controller recebe a informacao e devolve para o cliente.

<br>
<br>

üí° Usar o construtor √© a melhor pr√°tica. Ele facilita a inje√ß√£o expl√≠cita de depend√™ncias **e ajuda nos testes unit√°rios.**
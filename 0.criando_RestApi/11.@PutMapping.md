<h1 align="center">
    @PutMapping
    <img src="https://cdn2.iconfinder.com/data/icons/top-search/128/_refresh_load_loading_sync_arrow_reload_restart-256.png" alt="routes icon" width="80px" align="center">
</h1>


Usamos a rota `@PutMapping` para alterar/update de um registro. O method que vamos usar para dar update em um registro √© o `.save()`

- `.save()` --> Se n√£o informarmos um #ID ou informarmos um #ID que n√£o exista, ser√° criado um registro
- `.save()` --> Se informarmos um #ID que exista no banco, ser√° alterado esse registro.


Seguindo o padrao de rotas Restful:


<img src="../imgs/restFull_routes.jpg" alt="restful routes image" width="550px">


<br>

Para conseguir entender bem as validacoes e para nao dar conflito, vamos fazer 2 coisinhas:

1. Remova a `NOT NULL` constraint dos campos da Entity "Student".

2. Remover o `DateTimerFormarter` do `toString()`,  se nao da ruim. Se n√£o enviarmos uma data, o DateTimerFormater nao tem como agir e pode dar problema.


## Controller

Nossa rota `@PostMapping` vai funcionar assim:

- Vamos informar na URL o #ID do item que queremos atualizar. `@PathVariable`.
- Vamos passar um objeto "Student" atrav√©s do `RequestBody`.



<br>

üí° SEMPRE QUE VAMOS ENVIAR/RECEBER um objeto, precisamos enviar um objeto DTO, somente com as informacoes necessarias.

Nesse caso, queremos editar um registro. Logo, nao precisamos do campo **#ID**. Basta criar um DTO sem o camp id. Assim, o usuario pode preencher o campo ID errado que nao sera criado um novo Student. Por isso a importancia dos DTOs.

<br>

```java
@PutMapping("/students/{id}")
public void updateStudent(@PathVariable("id") Long id, @RequestBody Student studentNovo){
    this.ss.updateStudent(id, studentNovo);
}
```


<br>

## Service

A nossa valida√ß√£o vai funcionar assim:

O usu√°rio ter√° flexibilidade em escolher quais campos ele deseja atualizar. Se ele deixar um campo em branco, esse campo n√£o vai sofrer alteracao, cotinuando com o mesmo valor que ele tinha.


- Se o campo "**dateOfBirth**" for preenchido, n√≥s atualizamos o "dateOfBirth" antigo.
- Se o campo "**name**" for preenchido, n√≥s atualizamos o "name" antigo.
- Se o campo "**email**" for preenchido, n√≥s verificamos:
    - Esse email j√° existe?
        - Esse email √© do pr√≥prio usu√°rio ou de outra pessoa?


<br>

üí° Sempre fa√ßa pequenos testes utilizando o `System.out.println();`. Assim, conseguimos ver como que est√° chegando um objeto Student pra n√≥s.

```java
public void updateStudent(Long id, Student studentNovo){
    Optional<Student> sOptional = this.sr.findById(id);

    //se nao encontrar o #ID do Student, n√£o conseguimos fazer update
    if(sOptional.isEmpty()){
        throw new StudentNotFoundException(String.format("Student #%d not found",id));
    }

    //Recuperamos o #ID do student antigo. Assim, garantimos que, ao usar o .save(), vamos apenas alterar o registro e nao criar um novo
    Student studentAntigo = sOptional.get();


    //validando os attributes/campos informados
    /* Se um campo for preenchido, vamos atualizar o campo do Student antigo
    * - campo "dateOfBirth" preenchido, atualizamos o campo antigo
    * - campo "name" preenchido, atualizamos o campo antigo
    * - campo "email" preenchido, verificamos:
    *       - verificamos se o "email" informado j√° existe.
    *               - Verificamos se o "email" √© do pr√≥prio student ou se √© de outra pessoa
    */

    if(studentNovo.getDateOfBirth() != null){
        studentAntigo.setDateOfBirth(studentNovo.getDateOfBirth());
    }

    if(studentNovo.getName() != null){
        studentAntigo.setName(studentNovo.getName());
    }

    if(studentNovo.getEmail() != null){
        //verificamos se existe no banco algum "Student" com o "email" informado
        Optional<Student> sOptionalEmail = this.sr.findByEmail(studentNovo.getEmail());

        if(sOptionalEmail.isPresent()){
            //verificamos se √© o email do proprio student ou se √© de outro student
            if(!(studentAntigo.getEmail().equals(studentNovo.getEmail()))){ //se for "email" de outra pessoa
                throw new EmailAlreadyExists("'E-mail' already exists!");
            }
        }
        //tudo ok, atualizamos o email
        studentAntigo.setEmail(studentNovo.getEmail());
    }
    this.sr.save(studentAntigo); //fazemos o update desse "Student" no banco
}
```
üòé


<hr>
<br>

‚úèÔ∏è Volte no [@PostMapping](./9.@PostMapping.md) e fa√ßa a mesma validacao ao criar um Student

As validacoes v√£o ser:

- O campo ‚ÄúdateOfBirth‚Äù n√£o pode ser null
- O campo ‚Äúname‚Äù n√£o pode ser null
- O campo ‚Äúemail‚Äù n√£o pode ser null
    - O ‚Äúemail‚Äù informado j√° existe no banco?


üí° O campo "age" n√£o precisa de validacao, pois j√° fizemos o calculo da idade utilizando o Period no method `getAge()`. Ent√£o... N√£o importa se o usu√°rio preencher ou n√£o a idade, pois quando chamarmos o `getAge()`, j√° vamos ter a idade correta.

```java
//SERVICE
public void createStudent(Student novoStudent){
    System.out.println("\n\n\n\n=================================================");
    System.out.println(novoStudent.toString());

    /* Faremos as seguintes validacoes:

        * - field "dateOfBirth" cannot be null
        * - field "name" cannot be null
        * - field "email" cannot be null
        *      - "email" already exists?
        * 
        */
    if(novoStudent.getDateOfBirth() == null){
        throw new DateOfBirthCannotBeNull("The field 'dateOfBirth' cannot be null. You must fill it with something.");
    }

    if(novoStudent.getName() == null){
        throw new NameCannotBeNull("The field 'name' cannot be null. You must fill it with something.");
    }

    if(novoStudent.getEmail() == null){
        throw new EmailCannotBeNull("The field 'email' cannot be null. You must fill it with something.");
    }


    Optional<Student> sOptional = this.sr.findByEmail(novoStudent.getEmail());
    if(sOptional.isPresent()){
        throw new EmailAlreadyExists("'Email' already exists. Choose another one.");
    }
    //salvamos no banco
    this.sr.save(novoStudent);
    }
```

<br>

Dale! Criamos nossa primeira API com Java + Spring. üòé
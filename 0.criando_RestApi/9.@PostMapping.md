<h1 align="center">
    @PostMapping - CREATE
    <img src="https://cdn3.iconfinder.com/data/icons/file-folders/64/1-30-256.png" alt="routes icon" width="80px" align="center">
</h1>

Para criar Students no nosso banco de dados, precisamos fazer um request do tipo `@PostMapping`.

`@PostMapping` --> **INSERT INTO**

Vamos enviar esse objeto Student atrav√©s do `@RequestBody`. Ou seja, vamos informar esse Student no body da requisi√ß√£o.

Sempre vamos seguir o padrao Restful:

<img src="../imgs/restFull_routes.jpg" alt="restful routes image" width="550px">



## Controller
Vamos criar a rota e o method para criar um Student

```java
@RestController //Essa class √© uma class controladora, que retorna objetos JSON
@RequestMapping(path = "/api/v1/") //setamos a rota padrao. Nesse caso http://localhost:8080/api/v1/
public class StudentController{

    //attributes injetados
    @Autowired
    private StudentService ss;


    //CREATE
    @PostMapping("/students")  //rota do tipo POST
    public void createStudent(@RequestBody Student s1){ //Vamos enviar esse objeto atrav√©s do "Body" do request/requisicao
        this.ss.createStudent(s1);
    }
}
```
Vamos chamar um method da Service.

<br>

## Service
Vamos chamar um method da Repository. Para criar objetos no banco, usamos o method `.save()` da Repository/JPA.

Aqui n√£o precisamos criar uma Query, pois o method `.save()` j√° salva no banco.


```java
@Service
public class StudentService {

    // injected attributes
    @Autowired
    StudentRepository sr;

    //CREATE
    public void createStudent(Student s1){
        this.sr.save(s1); //salvamos no banco
    }
}
```

üí° Importante lembrar que o method `.save()` da JPA pode tanto criar um registro como alterar um registro.

- `.save()` --> Se voc√™ n√£o informar o campo *#ID*, √© criado um novo registro
- `.save()` --> Se voc√™ informar o campo *#ID*, √© alterado o registro com esse ID

Entao sempre que quisermos cadastrar um novo registro, n√£o informamos o campo #ID ou informamos um id que n√£o exista. A√≠ sim, ser√° criado um novo registro.

<br>

## Repository

```java
@Repository
public interface StudentRepository extends JpaRepository<Student, Long>{
    //queries

    //CREATE
}
```

üìñ N√£o precisamos criar uma query para salvar no banco. Vamos usar o method `.save()` j√° criado pela JPA.

<hr>
<br>

## Criando um objeto
V√° no postman e crie um request do tipo **Post**. L√° no body do request, informe o objeto que voce deseja criar.

<img src="./imgs/request_body.png" alt="restful routes image" width="700px">

Dale!!

<hr>
<br>

## Validando melhor a criacao de um Student
Perceba que voc√™ pode criar outros students com e-mails iguais. Isso n√£o pode acontecer.

Para tratar isso, vamos seguir a seguinte l√≥gica:

1. Verificamos se existe algum "Student" com o email informado.

2. Se n√£o existir, criamos esse student. Se existir, lancamos um erro.


<br>


### Repository
O JPA j√° possui um method para procurar por determinado campo. Por√©m, √© mais legal, criarmos nossa propria query.

```java
@Repository
public interface StudentRepository extends JpaRepository<Student, Long>{

    //queries

    //FindByEmail
    @Query(value = "SELECT s FROM Student s WHERE s.email = :emailProcurado")
    public Optional<Student> findByEmail(@Param("emailProcurado") String emailProcurado);
    
}
```

Sempre que estivermos criando nossa query na m√£o, vamos precisar usar 2 annotations em conjunto:

`@Query` + `@Param`

- `@Query` --> Informamos a query que queremos realizar
- `@Param` --> Informamos que "tal" parametro do method vai ser mencionado na query.


<br>
<br>


### Service
Agora sim, podemos validar o student que ser√° cadastrado.

Sempre que vamos trabalhar com findById, findByAlgumAttribute, etc... Precisamos usar a Class `Optional<>`.

Essa class pode retonar null, caso n√£o encontre nenhum registro no banco, ou retornar de fato um objeto.


Concorda que, se estamos procurando por um "Student" com tal email, pode ser que ele de fato exista, ou pode ser que n√£o encontremos nada(null). Por isso precisamos usar a Class `Optional<>`.

```java
@Service
public class StudentService {

    // injected attributes
    @Autowired
    StudentRepository sr;


    //CREATE
    public void createStudent(Student s1){
        //verificando se j√° existe um "student" com o email informado
        Optional<Student> sOptional = this.sr.findByEmail(s1.getEmail());
        
        //se retornar de fato um "Student", quer dizer que o email ja existe
        if(sOptional.isPresent()){ 
            throw new IllegalStateException("email already exists");
        }
        //se retornar null, quer dizer que n√£o existe nenhum student com esse email
        this.sr.save(s1); //salvamos no banco
    }
  
}
```


‚úèÔ∏è Tente criar 2 Student com o mesmo email. Viu??

üìñ Sempre que quisermos buscar no banco, filtrando por tal attribute/campo, precisamos utilziar a class `Optional<>`. Pode ser que encontramos de fato o registro, ou n√£o(null).

Tem v√°rias outros tratamento que precisamos fazer, mas vamos fazer isso depois.
<h1 align="center">
    @PutMapping
    <img src="https://cdn2.iconfinder.com/data/icons/top-search/128/_refresh_load_loading_sync_arrow_reload_restart-256.png" alt="routes icon" width="80px" align="center">
</h1>


Usamos a rota `@PutMapping` para alterar/update de um registro. O method que vamos usar para dar update em um registro √© o `.save()`

- `.save()` --> Se n√£o informarmos um #ID ou informarmos um #ID que n√£o exista, ser√° criado um registro
- `.save()` --> Se informarmos um #ID que exista no banco, ser√° alterado esse registro.


Seguindo o padrao de rotas Restful:


<img src="https://encurtador.com.br/abxBK" alt="restful routes image" width="550px">


<br>

Para conseguir entender bem as validacoes e para nao dar conflito, vamos fazer 2 coisinhas:

1. Remova a `NOT NULL` constraint dos campos da Entity "Student".

2. Remover o `DateTimerFormarter` do `toString()`,  se nao da ruim. Se n√£o enviarmos uma data, o DateTimerFormater nao tem como agir e pode dar problema.


## Controller

Nossa rota `@PostMapping` vai funcionar assim:

- Vamos informar na URL o #ID do item que queremos atualizar. `@PathVariable`.
- Vamos passar um objeto "Student" atrav√©s do `RequestBody`.

<br>

```java
@PutMapping("/students/{id}")
public void updateStudent(@PathVariable("id") Long id, @RequestBody Student studentNovo){
    this.ss.updateStudent(id, studentNovo);
}
```


<br>

## Service

A nossa valida√ß√£o vai funcionar assim:

O usu√°rio ter√° flexibilidade em escolher quais campos ele deseja atualizar. Se ele deixar um campo em branco, esse campo n√£o vai sofrer alteracao, cotinuando com o mesmo valor que ele tinha.


- Se o campo "**dateOfBirth**" for preenchido, n√≥s atualizamos o "dateOfBirth" antigo.
- Se o campo "**name**" for preenchido, n√≥s atualizamos o "name" antigo.
- Se o campo "**email**" for preenchido, n√≥s verificamos:
    - Esse email j√° existe?
        - Esse email √© do pr√≥prio usu√°rio ou de outra pessoa?



```java
public void updateStudent(Long id, Student studentNovo){
    Optional<Student> sOptional = this.sr.findById(id);

    //se nao encontrar o #ID do Student, n√£o conseguimos fazer update
    if(sOptional.isEmpty()){
        throw new StudentNotFoundException(String.format("Student #%d not found",id));
    }

    //Recuperamos o #ID do student antigo. Assim, garantimos que, ao usar o .save(), vamos apenas alterar o registro e nao criar um novo
    Student studentAntigo = sOptional.get();


    //validando os attributes/campos informados
    /* Se um campo for preenchido, vamos atualizar o campo do Student antigo
    * - campo "dateOfBirth" preenchido, atualizamos o campo antigo
    * - campo "name" preenchido, atualizamos o campo antigo
    * - campo "email" preenchido, verificamos:
    *       - verificamos se o "email" informado j√° existe.
    *               - Verificamos se o "email" √© do pr√≥prio student ou se √© de outra pessoa
    */

    if(studentNovo.getDateOfBirth() != null){
        studentAntigo.setDateOfBirth(studentNovo.getDateOfBirth());
    }

    if(studentNovo.getName() != null){
        studentAntigo.setName(studentNovo.getName());
    }

    if(studentNovo.getEmail() != null){
        //verificamos se existe no banco algum "Student" com o "email" informado
        Optional<Student> sOptionalEmail = this.sr.findByEmail(studentNovo.getEmail());

        if(sOptionalEmail.isPresent()){
            //verificamos se √© o email do proprio student ou se √© de outro student
            if(!(studentAntigo.getEmail().equals(studentNovo.getEmail()))){ //se for "email" de outra pessoa
                throw new EmailAlreadyExists("'E-mail' already exists!");
            }
        }
        //tudo ok, atualizamos o email
        studentAntigo.setEmail(studentNovo.getEmail());
    }
    this.sr.save(studentAntigo); //fazemos o update desse "Student" no banco
}
```
üòé


<br>

‚úèÔ∏è Volte no [@PostMapping](./9.@PostMapping.md) e fa√ßa a mesma validacao ao CREATE um Student

As validacoes v√£o ser:

- O campo ‚ÄúdateOfBirth‚Äù n√£o pode ser null
- O campo ‚Äúname‚Äù n√£o pode ser null
- O campo ‚Äúemail‚Äù n√£o pode ser null
    - O ‚Äúemail‚Äù informado j√° existe no banco?